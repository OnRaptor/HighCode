@page "/tasks"
@using HighCode.Domain.DTO
@using HighCode.Domain.Models
@using HighCode.Domain.Responses
@using HighCode.Domain.Constants
@using HighCode.Domain.ApiRequests.Tasks
@using Refit
@using HighCode.Client.Components.Dialogs
@inject IHighCodeAPI api;
@inject ISnackbar SnackbarService
@inject IDialogService DialogService

<MudContainer MaxWidth="MaxWidth.Small">
    <MudStack Wrap="Wrap.Wrap" Row="true" Spacing="2">
        <MudText Typo="Typo.h6">Задачи (@CodeTasks?.Count)</MudText>
        <AuthorizeView Policy="StaffOnly">
            <MudButton OnClick="() => AddTaskClick()" Variant="Variant.Filled" Color="Color.Primary">Добавить задачу</MudButton>
        </AuthorizeView>
        <AuthorizeView Policy="UserOnly">
            <MudButton OnClick="() => AddTaskClick(true)" Variant="Variant.Filled" Color="Color.Primary">Предложить задачу</MudButton>
        </AuthorizeView>
    </MudStack>
    @if (CodeTasks == null)
    {
        <MudProgressCircular Indeterminate="true"/>
    }
    else
    {
        <MudGrid >
            <MudItem>
                <MudTextField Placeholder="Поиск..." Variant="Variant.Outlined" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" FullWidth="true" T="string" @bind-Value="@searchQuery" @bind-Value:after="LoadTasks"></MudTextField>
            </MudItem>
            <MudItem>
                <MudExpansionPanel Style="background: transparent;" Dense="true" DisableGutters="true" Class="mt-2" Text="Фильтры">
                    <MudStack Spacing="2">
                        @foreach (var filterType in filterValues.Keys)
                        {
                            @switch (filterType)
                            {
                                case FilterTypeConstants.ByCategory:
                                case FilterTypeConstants.ByLanguage:
                                {
                                    <MudTextField Variant="Variant.Outlined" Label="@filterType" @bind-Value:get="@((string?)GetFilterValue(filterType))" @bind-Value:set="(e) => ApplyFilterValue(filterType, e)" T="string?"/>
                                    break;
                                }
                                case FilterTypeConstants.ByComplexity:
                                {
                                    <MudSelect Variant="Variant.Outlined" T="int?" @bind-Value:get="@((int?)GetFilterValue(filterType))" @bind-Value:set="(e) => ApplyFilterValue(filterType, e)" Label="Сложность">
                                        <MudSelectItem T="int?" Value="@(null)">Нет</MudSelectItem>
                                        <MudSelectItem T="int?" Value="0">Легко</MudSelectItem>
                                        <MudSelectItem T="int?" Value="1">Средне</MudSelectItem>
                                        <MudSelectItem T="int?" Value="2">Сложно</MudSelectItem>
                                    </MudSelect>
                                    break;
                                }
                            }
                        }
                        <MudButton OnClick="ClearFilters" Color="Color.Error">Очистить фильтры</MudButton>
                    </MudStack>
                </MudExpansionPanel>
            </MudItem>
        </MudGrid>

        @foreach (var task in CodeTasks)
        {
            <MudCard Outlined="true" Class="mt-5">
                <MudCardHeader Class="pb-0">
                    <CardHeaderContent>
                        <MudText Color="Color.Info" Typo="Typo.h6">@task.Title</MudText>
                    </CardHeaderContent>
                    <CardHeaderActions>
                        <AuthorizeView Policy="StaffOnly">
                            <MudIconButton Icon="@Icons.Material.Filled.Edit" OnClick="() => EditTaskClick(task)" Variant="Variant.Text" Color="Color.Warning"></MudIconButton>
                        </AuthorizeView>
                    </CardHeaderActions>
                </MudCardHeader>
                <MudCardContent Class="pt-0">
                    <MudText Class="trim_text" Typo="Typo.body1">@task.Description</MudText>
                    <MudStack Row="true">
                        @if (!string.IsNullOrEmpty(task.Category))
                        {
                            <MudChip OnClick='() => ApplyFilterValue("category", task.Category)' Variant="Variant.Filled" Color="Color.Info">@task.Category</MudChip>
                        }
                        <MudChip OnClick='() => ApplyFilterValue("language", task.ProgrammingLanguage)' Variant="Variant.Filled">@task.ProgrammingLanguage</MudChip>
                        <MudChip OnClick='() => ApplyFilterValue("complexity", task.Complexity)' Variant="Variant.Filled">@(TaskDTO.ComplexityToString(task.Complexity.GetValueOrDefault()))</MudChip>
                    </MudStack>
                </MudCardContent>
                <MudCardActions>
                    <MudStack Class="pl-2" Row="true" Spacing="2" Wrap="Wrap.Wrap">
                        <MudButton Href=@("/solution/" + task.Id) Variant="Variant.Filled" Color="Color.Primary">Начать решать</MudButton>
                        <MudButton Href=@("/taskdetails/" + task.Id) Variant="Variant.Text" Color="Color.Secondary">Подробнее</MudButton>
                    </MudStack>
                </MudCardActions>
            </MudCard>
        }
    }
</MudContainer>
@code {
    ICollection<TaskDTO>? CodeTasks { get; set; }
    GetAllGroupTypes requestGroupType = GetAllGroupTypes.Default;
    string searchQuery { get; set; }

    Dictionary<string, object?> filterValues
        = new(FilterTypeConstants
            .GetAll()
            .Select(x => KeyValuePair.Create<string, object?>(x, null)));

    async Task LoadTasks()
    {
        try
        {
            var r = await api.GetTasks(new GetAllTaskQuery
            {
                GroupType = requestGroupType,
                SearchQuery = searchQuery,
                Filters = filterValues
                    .Where(x => x.Value != null)
                    .Select(x => new GetAllTaskQuery.FilterType(x.Key, x.Value.ToString()))
            });
            if (r is { Success: true })
            {
                CodeTasks = r.Tasks.ToList();
                StateHasChanged();
            }
        }
        catch (ApiException e)
        {
            var error = await e.GetContentAsAsync<ErrorResponse>();
            SnackbarService.Add(error.ErrorMessage, Severity.Error);
        }
    }

    async void ClearFilters()
    {
        filterValues
            = new Dictionary<string, object>(FilterTypeConstants
                .GetAll()
                .Select(x => KeyValuePair.Create<string, object?>(x, null)));
        await LoadTasks();
    }

    async void ApplyFilterValue(string type, object value)
    {
        filterValues[type] = value;
        await LoadTasks();
    }

    object? GetFilterValue(string type)
    {
        return filterValues[type];
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await LoadTasks();

        await base.OnAfterRenderAsync(firstRender);
    }

    private async void EditTaskClick(TaskDTO oldTask)
    {
        try
        {
            var dialog = await DialogService.ShowAsync<EditTaskDialog>(null,
                new DialogParameters<EditTaskDialog>
                {
                    {
                        x => x.Task, oldTask
                    }
                },
                new DialogOptions()
                {
                    MaxWidth = MaxWidth.Medium,
                    FullWidth = true
                });
            var dialogResult = await dialog.Result;

            if (dialogResult.Canceled) return;

            var newTask = dialogResult.Data as TaskDTO;
            var r = await api.EditTask(new EditTaskCommand()
            {
                TaskId = oldTask.Id,
                Task = newTask
            });
            SnackbarService.Add(r.Message, Severity.Info);
            StateHasChanged();
        }
        catch (ApiException e)
        {
            var error = await e.GetContentAsAsync<ErrorResponse>();
            SnackbarService.Add(error.ErrorMessage, Severity.Error);
        }
    }

    private async void AddTaskClick(bool userSuggest=false)
    {
        var dialog = await DialogService.ShowAsync<CreateTaskDialog>(null,
        new DialogParameters<CreateTaskDialog>
        {
            {
                x => x.isUserSuggest, userSuggest
            }
        },
        new DialogOptions()
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        });
        var dialogResult = await dialog.Result;
        if (dialogResult.Canceled) return;

        try
        {
            var task = dialogResult.Data as TaskDTO;
            var r = await api.CreateTask(task);
            SnackbarService.Add(r.Message, Severity.Info);
            await LoadTasks();
        }
        catch (ApiException e)
        {
            var error = await e.GetContentAsAsync<ErrorResponse>();
            SnackbarService.Add(error.ErrorMessage, Severity.Error);
        }
    }


}